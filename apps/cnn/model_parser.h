//
// Created by debora on 25.06.22.
//

#ifndef CECILIA_MODEL_PARSER_H
#define CECILIA_MODEL_PARSER_H

#include <cstdlib>
#include <string>
#include <fstream>   // to read file
#include <iostream>  // for cout
#include <utility>
#include <vector>

const char col_delim = ',';
const char* white_space = &" \t\n\r\f\v" [col_delim]; // any whitespace to be removed

const string file_ending = ".txt";
// constants for CHAMELEON
const string ch_conv_name = "ws_conv0_filter";
// constants for LeNet
const string le_conv_name0 = "conv0_weight_";
const string le_conv_name1 = "conv1_weight_";
const string le_conv_name2 = "conv2_weight_";

// constants for MINIONN
const char row_start = '[', row_end = ']', name_end = ':';
const string initializer_id = "L=", input_id = "I=", dim_id = "dim_value:";

using namespace std;

/**
 * the following 3 functions are derived from here: https://stackoverflow.com/questions/216823/how-to-trim-a-stdstring
 */
// trim from end of string (right)
string rtrim(string s, const char* ws = white_space)
{
    s.erase(s.find_last_not_of(ws) + 1);
    return s;
}

// trim from beginning of string (left)
string ltrim(string s, const char* ws = white_space)
{
    s.erase(0, s.find_first_not_of(ws));
    return s;
}

// trim from both ends of string (right then left) all empty spaces and delimiter
string trim(string s, const char* ws = white_space)
{
    return ltrim(rtrim(std::move(s), ws), ws);
}

double ** transpose(double** matrix, uint32_t rows, uint32_t cols){
    double ** res = new double *[cols];
    for (int c = 0; c < cols; ++c) {
        res[c] = new double [rows];
        for(int r = 0; r<rows; r++) {
            res[c][r] = matrix[r][c];
        }
    }
    return res;
}

/**
 * Get the model parameters of the model specified in the file at model_file_path
 * @param model_file_path path to the file specifying the weights of the layer.
 * This is expected to be an txt file generated by model_parser.ipynb, which parses the original onnx file.
 * @param dimensions specification of several dimensions in a vector. The following values will be at the according positions:
 * position 0: number of weight dimensions. This value divided by 2 will be the number of layers of the model.
 * position i: for all odd numbers i in [1, number_of_layer*2]: first dimension of the ceil(i/2) th layer.
 * position j: for all even numbers j in [2, number_of_layer*2 + 1]: second dimension of the j/2 th layer.
 * If a value at a position j is -1, the according weights matrix is a one dimensional vector.
 * position number_of_layer*2 + 2 to number_of_layer*2 + 5 contain the four dimensional values for the input of the model.
 * The order of those four values is [i_number, i_channel, i_widht, i_height]
 * @param number_of_layer number of layer for which weights shall be parsed.
 * @return pointer to the 3D matrix holding the weights of all layer in 2D shape.
 */
double*** getONNXParameters(const string& model_file_path, vector<int> &dimensions, uint32_t number_of_layer){
    auto ***weights = new double **[2*number_of_layer+1];
    //read weights of each layer from model:
    fstream weights_file;
    weights_file.open(model_file_path, ios::in);
    if (weights_file.is_open()){
        // helper variables
        string line;
        uint32_t dimensionality = 0;
        int valueEnd;
        int row, col, kern = -1;
        bool continueParsing = true;
        while (getline(weights_file,line).good() && continueParsing){
            // line starts with L= and contains number of layers afterwards.
            if (line.find(initializer_id) == 0 && line.length() >= 2 && (kern + 1) < number_of_layer){
                // +7 because 5 values are additional to weights stored and 2 will be added in this branch
                if(dimensions.size() < number_of_layer * 2 + 7){
                    kern++; row = -1; col = 0;
                    uint32_t nameEndPos = line.find(name_end);
                    string dims = line.substr(nameEndPos+1);
                    int middle = static_cast<int>(dims.find(col_delim));
                    if (middle >= 0 && middle != string::npos){
                        // two-dimensional; in theory it could also be >2D but shouldn't be the case here.
                        dimensionality = 2;
                        dimensions.insert(dimensions.end(), stoi(dims.substr(0,middle)));
                        dimensions.insert(dimensions.end(),stoi(dims.substr(middle + 2)));
                    }
                    else{
                        dimensionality = 1;
                        dimensions.insert(dimensions.end(), stoi(dims));
                        dimensions.insert(dimensions.end(), -1);
                    }
                    weights[kern] = new double *[dimensions.at(kern*2)];
                }
            }
            else if(line.find(input_id) == 0){
                if(line == "I=1:"){
                    while(getline(weights_file,line).good() && line.find(input_id) != 0){
                        //parse specification of this one input.
                        int start = static_cast<int>(line.find(dim_id));
                        if(start != string::npos && (start + dim_id.length()) < line.length()){
                            string dim_value = line.substr(start + dim_id.length());
                            dimensions.insert(dimensions.end(), stoi(dim_value));
                        }
                    }
                    // all other Input dimensions will match the ones already parsed. from L=... lines
                    continueParsing = false;
                }
            }
            // parse weights of the according layer:
            else {
                switch (dimensionality) {
                    case 1:{
                        row++;
                        weights[kern][row] = new double [1];
                        line = trim(line);
                        weights[kern][row][0] = stod(line);
                        break;
                    }
                    case 2:{
                        // if dimensionality == 1, rows are not separated by []
                        if (line.at(0) == row_start) {
                            line = line.substr(1);
                            row++; // was initialized with -1
                            col = 0;
                            weights[kern][row] = new double [dimensions.at(kern*2 + 1)];
                        }
                        else if (line.at(line.length()-1) == row_end) {
                            line = line.substr(0, line.length() - 1);
                        }
                        line = trim(line);

                        // store values of this row in weights matrix
                        valueEnd = static_cast<int>(line.find(col_delim));
                        uint32_t valueStart = 0;
                        while (valueEnd != string::npos){
                            string value = line.substr(valueStart, valueEnd-valueStart);
                            weights[kern][row][col] = stod(value);
                            valueStart = valueEnd+1;

                            valueEnd = static_cast<int>(line.find(col_delim, valueStart));
                            col++;
                        }
                        break;
                    }
                    default: {
                        cout << "Dimensionality " << dimensionality << " can not be processed by model parser. Sorry!"
                             << endl;
                        break;
                    }
                }
            }
        }
        weights_file.close();
        dimensions.insert(dimensions.begin(), (kern+1)*2);
    }
    return weights;
}

// START Parsing Helper functions for LeNet and Chameleon:
/**
 * Parses all Kernel files which are at the given directory and of the following name pattern:
 * file_name_prefix + \<number of kernel\> + file_ending. \<number of kernel\> is a value in [0, number_of_kernels-1]
 * @param file_dir the directory where the files to be read are located
 * @param file_name_prefix prefix of the naming convention of the files
 * @param number_of_kernels number of files to be parsed.
 * @param i_channel number of input channel per kernel
 * @param number_of_values_in_kernel number of expected values to be parsed per kernel.
 * @return a 3D matrix where the first dimension is the different kernels (from the different files),
 * the second dimension is the one of input channels which is currently always 1
 * the third dimension is the values of the kernel which are 25
 */
double*** parseAllKernelFiles(const string& file_dir, const string& file_name_prefix, uint32_t number_of_kernels, uint32_t i_channel, uint32_t number_of_values_in_kernel){
    auto*** weights = new double **[number_of_kernels];
    string line;
    for (uint32_t k = 0; k<number_of_kernels; k++){
        weights[k] = new double *[i_channel]; // only one input channel
        // init file reading
        fstream cv_weights_file;
        string file_path = file_dir + file_name_prefix;
        file_path += to_string(k) + file_ending;
        cv_weights_file.open(file_path, ios::in);
        if(cv_weights_file.is_open()){
            // actual parsing
            uint32_t position = 0;
            int c = 0;
            weights[k][c] = new double [number_of_values_in_kernel];
            int valueEnd;
            while (getline(cv_weights_file, line).good()){
                line = trim(line);
                // store values of this row in weights matrix
                valueEnd = static_cast<int>(line.find(col_delim));
                uint32_t valueStart = 0;
                while (valueEnd != string::npos){
                    string value = line.substr(valueStart, valueEnd-valueStart);
                    weights[k][c][position] = stod(value);
                    valueStart = valueEnd+1;

                    valueEnd = static_cast<int>(line.find(col_delim, valueStart));
                    position++;
                    if(position >= (number_of_values_in_kernel)){
                        cerr << "Not all values can be parsed from " << file_path << endl;
                        return nullptr;
                    }
                }
                // last value not yet stored:
                weights[k][c][position] = stod(line.substr(valueStart));
                position++;
                if(position == number_of_values_in_kernel){
                    // next channel
                    position = 0;
                    c++;
                    weights[k][c] = new double [number_of_values_in_kernel];
                }
            }
            cv_weights_file.close();
        }
    }
    return weights;
}

/**
 * Parse the parameters specified in a file, separated by col_delim.
 * @param file_path path to the parameter file to be parsed
 * @param rows number of rows expected to be parsed in this file. If the number of rows in the file exceeds this parameter, nullptr will be returned.
 * @param cols number of cols expected to be parsed in this file. If the number of parameters per row in the file exceeds this parameter, nullptr will be returned.
 * @param flatten defines if all parameters of the file shall be stored in a single row of the output.
 * @return The parameters parsed from the given file or
 * nullptr if rows or cols is smaller than the number of rows or number of parameters per row found in the file.
 */
double*** parse2DParams(const string& file_path, uint32_t rows, uint32_t cols, bool flatten) {
    auto *** params = new double **[1];
    if(flatten){
        params[0] = new double *[1];
    }
    else{
        params[0] = new double *[rows];
    }
    fstream file_stream;
    file_stream.open(file_path, ios::in);
    string line;
    if(file_stream.is_open()){
        // actual parsing
        uint32_t col = 0;
        uint32_t row = 0;
        int valueEnd;
        while (getline(file_stream, line).good()){
            line = trim(line);
            if(flatten){
                if(col == 0){
                    params[0][0] = new double [rows*cols];
                }
                if(cols > 1){
                    valueEnd = static_cast<int>(line.find(col_delim));
                    uint32_t valueStart = 0;
                    while (valueEnd != string::npos){
                        string value = line.substr(valueStart, valueEnd-valueStart);
                        params[0][row][col] = stod(value);
                        valueStart = valueEnd+1;

                        valueEnd = static_cast<int>(line.find(col_delim, valueStart));
                        col++;
                    }
                    // last value not yet stored:
                    params[0][row][col] = stod(line.substr(valueStart));
                }
                else if(cols == 1){
                    // there is no col_delim to find
                    params[0][row][col] = stod(line);
                    col++;
                }
            }
            else{
                params[0][row] = new double [cols];
                // store values of this row in weights matrix
                valueEnd = static_cast<int>(line.find(col_delim));
                uint32_t valueStart = 0;
                while (valueEnd != string::npos){
                    string value = line.substr(valueStart, valueEnd-valueStart);
                    params[0][row][col] = stod(value);
                    valueStart = valueEnd+1;

                    valueEnd = static_cast<int>(line.find(col_delim, valueStart));
                    col++;
                }
                // last value not yet stored:
                params[0][row][col] = stod(line.substr(valueStart));
                col = 0;
                row++;
                if(row > rows){
                    cerr << "Rows found in file " << file_path << " exceeds number of rows expected (" << rows << ") !" << endl;
                    return nullptr;
                }
            }
        }
        file_stream.close();
    }
    return params;
}
/**
 * Switches dimension 0 and 1 of a given 3D matrix.
 * @param matrix of shape @p n_matrices x @p height x @p width
 * @param n_matrices number of 2D matrices in matrix
 * @param height number of rows in each 2D matrix
 * @param width number of cols in each 2D matrix
 * @return a matrix with dimensions 0 and 1 of @p matrix switched so that the output shape is
 * @p height x @p n_matrices x @p width
 */
double *** switchDimensions0and1(double*** matrix, int n_matrices, int height, int width){
    double *** switchedMatrix = new double **[height];
    for (int row = 0; row < height; ++row) {
        switchedMatrix[row] = new double *[n_matrices];
        for (int n = 0; n < n_matrices; ++n) {
            switchedMatrix[row][n] = matrix[n][row];
        }
    }
    return switchedMatrix;
}
// END helper functions


/**
 * Get the model parameters from the CellCNN trained on single cell data to classify between NIND and healthy donors. The parameters are specified by the files
 * in the specified directory.
 * @param model_file_dir directory to all files specifying weights of one convolutional layer and one fully connected layer.
 * The files are expected to be plain txt files containing nothing than the values separated by col_delim and only for weights with one channel.
 * @param number_of_kernel defines the number of kernels used in the convolutional layer. Kernels in the convolutional layer have size 35x1.
 * For each kernel, another file specifying the parameters is in the given model_file_dir, furthermore, one for the bias values.
 * Two further files can be found there specifying the fully connected layers' weights and bias.
 * @return a 4D vector where the first dimension combines all weights of a layer or all biases, so the first dimension will be of size 4.
 * the second dimension specifies the the input channel. For bias this is always 1
 * The third dimension specifies values of a kernel. Only the convolutional layer uses several kernel but for second and
 * third layer, the third dimensions size will be 1.
 * The fourth dimension specifies the length of the kernel/number of kernel values. For 5x5 kernel, this will be 25.
 */
double**** getCellCnnParameters(const string& model_file_dir, uint32_t number_of_kernel){
    auto ****weights = new double ***[6]; // 1 CL, 1 FCL, bias for each layer

    // convolutional layer:
    weights[0] = parseAllKernelFiles(model_file_dir, le_conv_name0, number_of_kernel, 1, 35);
    print2DArray("cl weights", weights[0][0], 1,35,true);

    // fully connected layer:
    string file_path = model_file_dir + "fc0_weight" + file_ending;
    weights[1] = parse2DParams(file_path, 8, 2, false);

    // bias
    file_path = model_file_dir + "conv0_bias" + file_ending;
    weights[2] = parse2DParams(file_path, 8, 1, true);

    file_path = model_file_dir + "fc0_bias" + file_ending;
    weights[3] = parse2DParams(file_path, 2, 1, true);

    return weights;
}

/**
 * Get the model parameters from the Chameleon CNN trained on the MNIST dataset. The parameters are specified by the files
 * in the specified directory.
 * @param model_file_dir directory to all the file specifying the weights of one convolutional layer and two fully connected layer.
 * The files are expected to be plain txt files containing nothing than the values separated by col_delim and only for weights with one channel.
 * @param number_of_kernel defines the number of kernels used in the convolutional layer. All kernel have size 5x5.
 * For each kernel, another file specifying the parameters is in the given model_file_dir.
 * Two further files can be found there specifying the fully connected layers' weights.
 * @return a 4D vector where the first dimension combines all weights of a layer or all biases, so the first dimension will be of size 6 (for three layer).
 * the second dimension specifies the the input channel. For bias this is always 1
 * The third dimension specifies values of a kernel. Only the convolutional layer uses several kernel but for second and
 * third layer, the third dimensions size will be 1.
 * The fourth dimension specifies the length of the kernel/number of kernel values. For 5x5 kernel, this will be 25.
 */
double**** getChameleonParameters(const string& model_file_dir, uint32_t number_of_kernel){
    auto ****weights = new double ***[6]; // 1 CL, 2 FCL, bias for each layer

    // convolutional layer:
    double*** parsedParams = parseAllKernelFiles(model_file_dir, ch_conv_name, number_of_kernel, 1, 25);
    weights[0] = switchDimensions0and1(parsedParams, number_of_kernel, 1, 25);

    // fully connected layer:
    string file_path = model_file_dir + "ws_dense0" + file_ending;
    weights[1] = parse2DParams(file_path, 980, 100, false);

    file_path = model_file_dir + "ws_dense1" + file_ending;
    weights[2] = parse2DParams(file_path, 100, 10, false);

    // bias
    file_path = model_file_dir + "bs_conv0" + file_ending;
    weights[3] = parse2DParams(file_path, 5, 1, true);

    file_path = model_file_dir + "bs_dense0" + file_ending;
    weights[4] = parse2DParams(file_path, 100, 1, true);

    file_path = model_file_dir + "bs_dense1" + file_ending;
    weights[5] = parse2DParams(file_path, 10, 1, true);

    return weights;
}

/**
 * Get the model parameters from the LeNet5 trained on the MNIST dataset. The parameters are specified by the files
 * in the specified directory.
 * @param model_file_dir directory to all the file specifying the weights of 2 convolutional layer and 2 fully connected layer.
 * The files are expected to be plain txt files containing nothing than the values separated by col_delim.
 * The first convolutional layer uses 6 kernel, the second one uses 16 kernel.
 * @return a 4D vector where the first dimension combines all weights of a layer or all biases, so the first dimension will be of size 8 (for four layer).
 * the second dimension specifies the the input channel. For bias this is always 1
 * The third dimension specifies values of a kernel. Only the convolutional layer uses several kernel but for second and
 * third layer, the third dimensions size will be 1.
 * The fourth dimension specifies the length of the kernel/number of kernel values. For 5x5 kernel, this will be 25.
 */
double**** getLeNetParameters(const string& model_file_dir, bool self_trained){
    double ****weights = new double ***[8]; // 2 CL, 2 FCL, bias for each layer
    string line;

    if(self_trained){
        cout << "parse params for LeNetNN" << endl;
        // convolutional layer:
        double*** parsedParams = parseAllKernelFiles(model_file_dir, le_conv_name0, 20, 1, 25);
        for (int k = 0; k < 3; ++k) {
            print2DArray("first row parsed weights", parsedParams[k], 1, 25);
        }
        weights[0] = switchDimensions0and1(parsedParams, 20, 1, 25);
        print2DArray("first row resorted weights", weights[0][0], 3, 25);
        parsedParams = parseAllKernelFiles(model_file_dir, le_conv_name1, 50, 20, 25);
        weights[1] = switchDimensions0and1(parsedParams, 50, 20, 25);
        //weights[2] = parseAllKernelFiles(model_file_dir, le_conv_name2, 800, 50);

        // fully connected layer:
        string file_path = model_file_dir + "fc0_weight" + file_ending;
        weights[2] = parse2DParams(file_path, 500, 800, false);
        weights[2][0] = transpose(weights[2][0], 500, 800);
        file_path = model_file_dir + "fc1_weight" + file_ending;
        weights[3] = parse2DParams(file_path, 10, 500, false);
        weights[3][0] = transpose(weights[3][0], 10, 500);

        // bias
        file_path = model_file_dir + "conv0_bias" + file_ending;
        weights[4] = parse2DParams(file_path, 20, 1, true);

        file_path = model_file_dir + "conv1_bias" + file_ending;
        weights[5] = parse2DParams(file_path, 50, 1, true);

        file_path = model_file_dir + "fc0_bias" + file_ending;
        weights[6] = parse2DParams(file_path, 800, 1, true);

        file_path = model_file_dir + "fc1_bias" + file_ending;
        weights[7] = parse2DParams(file_path, 500, 1, true);
    }
    else{ //this part is for the parameters obtained by matlab script
        // convolutional layer:

        double*** parsedParams = parseAllKernelFiles(model_file_dir, le_conv_name0, 6, 1, 25);
        weights[0] = switchDimensions0and1(parsedParams, 6, 1, 25);
        parsedParams = parseAllKernelFiles(model_file_dir, le_conv_name1, 16, 6, 25);
        weights[1] = switchDimensions0and1(parsedParams, 16, 6, 25);
        //weights[2] = parseAllKernelFiles(model_file_dir, le_conv_name2, 120);

        // fully connected layer:
        string file_path = model_file_dir + "fc0_weight" + file_ending;
        weights[2] = parse2DParams(file_path, 120, 84, false);

        file_path = model_file_dir + "fc1_weight" + file_ending;
        weights[3] = parse2DParams(file_path, 84, 10, false);

        // bias
        file_path = model_file_dir + "conv0_bias" + file_ending;
        weights[4] = parse2DParams(file_path, 6, 1, true);

        file_path = model_file_dir + "conv1_bias" + file_ending;
        weights[5] = parse2DParams(file_path, 16, 1, true);

        file_path = model_file_dir + "fc0_bias" + file_ending;
        weights[6] = parse2DParams(file_path, 120, 1, true);

        file_path = model_file_dir + "fc1_bias" + file_ending;
        weights[7] = parse2DParams(file_path, 10, 1, true);
    }
    return weights;
}

#endif //CECILIA_MODEL_PARSER_H
