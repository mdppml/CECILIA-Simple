//
// Created by debora on 25.06.22.
//

#ifndef CECILIA_MODEL_PARSER_H
#define CECILIA_MODEL_PARSER_H

#include <cstdlib>
#include <string>
#include <fstream>   // to read file
#include <iostream>  // for cout
#include <vector>

const char col_delim = ',';
const char* white_space = &" \t\n\r\f\v" [ col_delim]; // any whitespace to be removed

// constants for CHAMELEON
const string conv_file_name = "ws_conv0_filter";
const string file_ending = ".txt";

// constants for MINIONN
const char row_start = '[', row_end = ']', name_end = ':';
const string initializer_id = "L=", input_id = "I=", dim_id = "dim_value:";

using namespace std;
string trim(string s, const char* ws=white_space);

/**
 * Get the model parameters of the model specified in the file at model_file_path
 * @param model_file_path path to the file specifying the weights of the layer.
 * This is expected to be an txt file generated by model_parser.ipynb, which parses the original onnx file.
 * @param dimensions specification of several dimensions in a vector. The following values will be at the according positions:
 * position 0: number of weight dimensions. This value divided by 2 will be the number of layers of the model.
 * position i: for all odd numbers i in [1, number_of_layer*2]: first dimension of the ceil(i/2) th layer.
 * position j: for all even numbers j in [2, number_of_layer*2 + 1]: second dimension of the j/2 th layer.
 * If a value at a position j is -1, the according weights matrix is a one dimensional vector.
 * position number_of_layer*2 + 2 to number_of_layer*2 + 5 contain the four dimensional values for the input of the model.
 * The order of those four values is [i_number, i_channel, i_widht, i_height]
 * @param number_of_layer number of layer for which weights shall be parsed.
 * @return pointer to the 3D matrix holding the weights of all layer in 2D shape.
 */
double*** getONNXParameters(const string model_file_path, vector<int> &dimensions, uint32_t number_of_layer){
    double ***weights = new double **[2*number_of_layer+1];
    //read weights of each layer from model:
    fstream weights_file;
    weights_file.open(model_file_path, ios::in);
    if (weights_file.is_open()){
        // helper variables
        string line;
        uint32_t dimensionality = 0;
        int valueEnd;
        int row, col, kern = -1;
        bool continueParsing = true;
        while (getline(weights_file,line).good() && continueParsing){
            // line starts with L= and contains number of layers afterwards.
            if (line.find(initializer_id) == 0 && line.length() >= 2 && (kern + 1) < number_of_layer){
                // +7 because 5 values are additional to weights stored and 2 will be added in this branch
                if(dimensions.size() < number_of_layer * 2 + 7){
                    kern++; row = -1; col = 0;
                    uint32_t nameEndPos = line.find(name_end);
                    string dims = line.substr(nameEndPos+1);
                    int middle = dims.find(col_delim);
                    if (middle >= 0 && middle != string::npos){
                        // two-dimensional; in theory it could also be >2D but shouldn't be the case here.
                        dimensionality = 2;
                        dimensions.insert(dimensions.end(), stoi(dims.substr(0,middle)));
                        dimensions.insert(dimensions.end(),stoi(dims.substr(middle + 2)));
                    }
                    else{
                        dimensionality = 1;
                        dimensions.insert(dimensions.end(), stoi(dims));
                        dimensions.insert(dimensions.end(), -1);
                    }
                    weights[kern] = new double *[dimensions.at(kern*2)];
                }
            }
            else if(line.find(input_id) == 0){
                if(line.compare("I=1:") == 0){
                    while(getline(weights_file,line).good() && line.find(input_id) != 0){
                        //parse specification of this one input.
                        cout << line << endl;
                        int start = line.find(dim_id);
                        if(start != string::npos && (start + dim_id.length()) < line.length()){
                            string dim_value = line.substr(start + dim_id.length());
                            dimensions.insert(dimensions.end(), stoi(dim_value));
                        }
                    }
                    // all other Input dimensions will match the ones already parsed. from L=... lines
                    continueParsing = false;
                }
            }
            // parse weights of the according layer:
            else {
                switch (dimensionality) {
                    case 1:{
                        row++;
                        weights[kern][row] = new double [1];
                        line = trim(line);
                        weights[kern][row][0] = stod(line);
                        break;
                    }
                    case 2:{
                        // if dimensionality == 1, rows are not separated by []
                        if (line.at(0) == row_start) {
                            line = line.substr(1);
                            row++; // was initialized with -1
                            col = 0;
                            weights[kern][row] = new double [dimensions.at(kern*2 + 1)];
                        }
                        else if (line.at(line.length()-1) == row_end) {
                            line = line.substr(0, line.length() - 1);
                        }
                        line = trim(line);

                        // store values of this row in weights matrix
                        valueEnd = line.find(col_delim);
                        uint32_t valueStart = 0;
                        while (valueEnd != string::npos){
                            string value = line.substr(valueStart, valueEnd-valueStart);
                            weights[kern][row][col] = stod(value);
                            valueStart = valueEnd+1;

                            valueEnd = line.find(col_delim, valueStart);
                            col++;
                        }
                        break;
                    }
                    default: {
                        cout << "Dimensionality " << dimensionality << " can not be processed by model parser. Sorry!"
                             << endl;
                        break;
                    }
                }
            }
        }
        weights_file.close();
        dimensions.insert(dimensions.begin(), (kern+1)*2);
    }
    return weights;
}

/**
 * Get the model parameters from the Chameleon CNN trained on the MNIST dataset. The parameters are specified by the files
 * in the specified directory.
 * @param model_file_dir directory to all the file specifying the weights of one convolutional layer and two fully connected layer.
 * The files are expected to be plain txt files containing nothing than the values separated by col_delim.
 * @param number_of_kernel defines the number of kernels used in the convolutional layer. All kernel have size 5x5.
 * For each kernel, another file specifying the parameters is in the given model_file_dir.
 * Two further files can be found there specifying the fully connected layers' weights.
 * @param i_channel defines the number of input channel (for maintainance/adaption, currently this should be always 1)
 * @return a 4D vector where the first dimension combines all weights of a layer, so the first dimension will be of size 3.
 * the second dimension specifies the values of a kernel.
 * Only the convolutional layer uses several kernel, for the second and third layer, the second dimensions size will be one.
 * The third dimension specifies the input channel.
 * The fourth dimension specifies the length of the kernel/number of kernel values. For 5x5 kernel, this will be 25.
 */
double**** getChameleonParameters(const string model_file_dir, uint32_t number_of_kernel, uint32_t i_channel){
    double ****weights = new double ***[3]; // 1 CL, 2 FCL
    string line;

    // convolutional layer:
    weights[0] = new double **[number_of_kernel];
    //read weights of each layer from model:
    for (uint32_t k = 0; k<number_of_kernel; k++){
        weights[0][k] = new double *[i_channel]; // only one input channel
        // init file reading
        fstream cv_weights_file;
        string file_path = model_file_dir + conv_file_name + to_string(k) + file_ending;
        cv_weights_file.open(file_path, ios::in);

        if(cv_weights_file.is_open()){
            for(uint32_t i = 0; i<i_channel; i++){
                weights[0][k][i] = new double [25];
                // actual parsing
                uint32_t position = 0;
                int valueEnd;
                while (getline(cv_weights_file, line).good()){
                    line = trim(line);
                    // store values of this row in weights matrix
                    valueEnd = line.find(col_delim);
                    uint32_t valueStart = 0;
                    while (valueEnd != string::npos){
                        string value = line.substr(valueStart, valueEnd-valueStart);
                        weights[0][k][i][position] = stod(value);
                        valueStart = valueEnd+1;

                        valueEnd = line.find(col_delim, valueStart);
                        position++;
                    }
                    // last value not yet stored:
                    weights[0][k][i][position] = stod(line.substr(valueStart));
                    position++;
                }
            }
        }
    }

    // fully connected layer:
    weights[1] = new double **[1]; // only one file
    weights[1][0] = new double *[980];
    fstream fc_weights_file;
    string file_path = model_file_dir + "ws_dense0" + file_ending;
    fc_weights_file.open(file_path, ios::in);

    if(fc_weights_file.is_open()){
        // actual parsing
        uint32_t col = 0;
        uint32_t row = 0;
        int valueEnd;
        while (getline(fc_weights_file, line).good()){
            weights[1][0][row] = new double [100];
            line = trim(line);
            // store values of this row in weights matrix
            valueEnd = line.find(col_delim);
            uint32_t valueStart = 0;
            while (valueEnd != string::npos){
                string value = line.substr(valueStart, valueEnd-valueStart);
                weights[1][0][row][col] = stod(value);
                valueStart = valueEnd+1;

                valueEnd = line.find(col_delim, valueStart);
                col++;
            }
            // last value not yet stored:
            weights[1][0][row][col] = stod(line.substr(valueStart));
            col = 0;
            row++;
        }
        fc_weights_file.close();
    }

    weights[2] = new double **[1]; // only one file
    weights[2][0] = new double *[100];
    fstream fc_weights_file2;
    file_path = model_file_dir + "ws_dense1" + file_ending;
    fc_weights_file2.open(file_path, ios::in);

    if(fc_weights_file2.is_open()){
        // actual parsing
        uint32_t col = 0;
        uint32_t row = 0;
        int valueEnd;
        while (getline(fc_weights_file2, line).good()){
            weights[2][0][row] = new double [10];
            line = trim(line);

            // store values of this row in weights matrix
            valueEnd = line.find(col_delim);
            uint32_t valueStart = 0;
            while (valueEnd != string::npos){
                string value = line.substr(valueStart, valueEnd-valueStart);
                weights[1][0][row][col] = stod(value);
                valueStart = valueEnd+1;

                valueEnd = line.find(col_delim, valueStart);
                col++;
            }
            // last value not yet stored:
            weights[2][0][row][col] = stod(line.substr(valueStart));
            col = 0;
            row++;
        }
        fc_weights_file2.close();
    }
    return weights;
}

// the following is derived from here: https://stackoverflow.com/questions/216823/how-to-trim-a-stdstring
// trim from end of string (right)
string rtrim(string s, const char* ws = white_space)
{
    s.erase(s.find_last_not_of(ws) + 1);
    return s;
}

// trim from beginning of string (left)
string ltrim(string s, const char* ws = white_space)
{
    s.erase(0, s.find_first_not_of(ws));
    return s;
}

// trim from both ends of string (right then left) all empty spaces and delimiter
string trim(string s, const char* ws)
{
    return ltrim(rtrim(s, ws), ws);
}



#endif //CECILIA_MODEL_PARSER_H
